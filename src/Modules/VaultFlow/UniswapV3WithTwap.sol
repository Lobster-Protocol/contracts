// Maxime / Thomas ignore
// SPDX-License-Identifier: GPLv3
pragma solidity ^0.8.28;

import "forge-std/Test.sol";

import {IVaultFlowModule} from "../../interfaces/modules/IVaultFlowModule.sol";
import {INav} from "../../interfaces/modules/INav.sol";
import {IERC20} from "@openzeppelin/contracts/interfaces/IERC20.sol";
import {IERC20Metadata} from "@openzeppelin/contracts/interfaces/IERC20Metadata.sol";
import {IERC4626} from "@openzeppelin/contracts/interfaces/IERC4626.sol";
import {IUniswapV3PoolMinimal} from "../../interfaces/uniswapV3/IUniswapV3PoolMinimal.sol";
import {BaseOp, Op} from "../../interfaces/modules/IOpValidatorModule.sol";
import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
import {LobsterVault} from "../../../src/Vault/Vault.sol";
import {UniswapUtils, Position} from "../../libraries/uniswapV3/UniswapUtils.sol";
import {INonFungiblePositionManager} from "../../interfaces/uniswapV3/INonFungiblePositionManager.sol";
import {PositionValue} from "../../libraries/uniswapV3/PositionValue.sol";
import {PoolAddress} from "../../libraries/uniswapV3/PoolAddress.sol";

uint16 constant BASIS_POINT_SCALE = 10_000;

// Hook used to take a fee when the vault collect its fees from a uniswap pool
contract UniswapV3VaultFlow is IVaultFlowModule, INav {
    using Math for uint256;

    uint32 constant TWAP_PERIOD = 3600; // 1 hour
    // the cut of the fees generated by the vault's positions, expressed in basis points
    uint256 immutable feeCutBasisPoint;
    IUniswapV3PoolMinimal public pool;
    INonFungiblePositionManager public positionManager;
    // True if the asset we want to express the price in is token0
    bool private immutable assetIsToken0;
    IERC20 public immutable poolToken0;
    IERC20 public immutable poolToken1;
    uint8 decimals0;
    uint8 decimals1;

    // The maximum acceptable price difference between the spot price and the TWAP price
    uint256 public constant MAX_ACCEPTABLE_PRICE_DIFF_BASIS_POINT = 150; // 1.5%

    constructor(
        IUniswapV3PoolMinimal _pool,
        INonFungiblePositionManager positionManager_,
        address asset,
        uint256 feeCutBasisPoint_
    ) {
        pool = _pool;

        // Ensure at least one of the tokens is WETH and save which one it is
        assetIsToken0 = address(_pool.token0()) == asset;
        require(
            assetIsToken0 || address(_pool.token1()) == asset, "UniswapV3VaultFlow: Neither token is the wanted asset"
        );

        poolToken0 = IERC20(_pool.token0());
        poolToken1 = IERC20(_pool.token1());

        decimals0 = IERC20Metadata(address(poolToken0)).decimals();
        decimals1 = IERC20Metadata(address(poolToken1)).decimals();

        positionManager = positionManager_;
        feeCutBasisPoint = feeCutBasisPoint_;
    }

    function _deposit(
        address caller,
        address receiver,
        uint256 assets,
        uint256 shares
    )
        external
        returns (bool success)
    {
        (uint256 spotPrice, uint256 twPrice) = getPrices();

        // refuse to deposit if the price is too volatile (i.e. the spot price is too far from the TWAP)
        // security measure to protect the depositor or the vault for a potential arbitrage attack
        requireLowVolatility(twPrice, spotPrice);

        LobsterVault vault = LobsterVault(msg.sender);

        vault.safeTransferFrom(IERC20(vault.asset()), caller, address(vault), assets);
        vault.mintShares(receiver, shares);

        emit IERC4626.Deposit(caller, receiver, assets, shares);

        return true;
    }

    function _withdraw(
        address caller,
        address receiver,
        address owner,
        uint256 assets,
        uint256 shares
    )
        external
        returns (bool success)
    {
        revert("use PositionValue");
        // (uint256 twPrice, uint256 spotPrice) = getPrices();

        // // if the volatility is too high and the withdrawer is advantaged (arbitrage), create a slippage to protect the vault
        // if (
        //     tooMuchVolatility(twPrice, spotPrice) == true && spotPrice < twPrice
        // ) {
        //     /*
        //         If spotPrice < twPrice, the vault tvl will be over evaluated and during withdrawal,
        //         the vault will transfer more eth than necessary.
        //         This snippets aims to fix this
        //         todo: We can also just refuse the withdrawal and add a specific function to withdraw with an explicit acceptance of the slippage (with a signed message)
        //     */

        //     // Estimate the slippage
        //     uint256 slippageDiffBasisPoint = spotPrice.mulDiv(
        //         BASIS_POINT_SCALE,
        //         twPrice
        //     ); // < 10_000 since

        //     // reduce the withdrawn asset amount accordingly
        //     assets = assets.mulDiv(slippageDiffBasisPoint, BASIS_POINT_SCALE);
        // }

        // LobsterVault vault = LobsterVault(msg.sender);

        // // todo: if needed, withdraw the tokens we need from uniswap

        // // Execute withdrawal
        // vault.burnShares(owner, shares);
        // vault.safeTransfer(IERC20(vault.asset()), receiver, assets);

        // emit IERC4626.Withdraw(caller, receiver, owner, assets, shares);

        // return true;
    }

    function totalAssets() external view returns (uint256 totalValue) {
        // suppose the caller is the vault
        return totalAssets_(LobsterVault(msg.sender));
    }

    function totalAssetsFor(LobsterVault vault) external view returns (uint256 totalValue) {
        return totalAssets_(vault);
    }

    function totalAssets_(LobsterVault vault) internal view returns (uint256 totalValue) {
        bool isVaultAssetToken0 = address(poolToken1)
        // todo: store vault asset to save gas ?
        == LobsterVault(vault).asset() ? true : false;

        require(
            isVaultAssetToken0 || address(poolToken1) == LobsterVault(vault).asset(),
            "None of the pool assets is the vault asset"
        );

        // Get the pool assets owned by the vault
        uint256 amount0 = poolToken0.balanceOf(address(vault));
        uint256 amount1 = poolToken1.balanceOf(address(vault));

        // Get all the positions in the pool (+ non collected fees)
        (Position memory position0, Position memory position1) = getUniswapV3Positions(address(vault));

        // Convert the non-vault asset token amounts to the vault asset token
        (uint160 sqrtPriceX96,,,,,,) = pool.slot0();
        uint256 spotPrice = UniswapUtils.getQuoteFromSqrtRatioX96(
            sqrtPriceX96, uint128(10 ** (isVaultAssetToken0 ? decimals1 : decimals0)), isVaultAssetToken0
        );
        if (isVaultAssetToken0) {
            // convert token0 to token1
            totalValue = amount0 + position0.value + position1.value.mulDiv(spotPrice, 10 ** decimals1);
        } else {
            // convert token1 to token0
            totalValue = amount1 + position1.value + position0.value.mulDiv(spotPrice, 10 ** decimals0);
        }
    }

    function requireLowVolatility(uint256 twapPrice, uint256 spotPrice) internal pure {
        // check if the spot price is within the acceptable range
        require(
            tooMuchVolatility(twapPrice, spotPrice) == false,
            "UniswapV3VaultOperations: Spot price is not within the acceptable range"
        );
    }

    function tooMuchVolatility(
        uint256 twPrice, // amount of token1 needed for 1 token0
        uint256 spotPrice // amount of token1 needed for 1 token0
    )
        internal
        pure
        returns (bool)
    {
        // calculate the acceptable price difference
        uint256 acceptablePriceDiff = twPrice.mulDiv(MAX_ACCEPTABLE_PRICE_DIFF_BASIS_POINT, BASIS_POINT_SCALE);
        /////
        // display the abs value between (spot +- acceptablePriceDiff) - twPrice
        console.log("acceptablePriceDiff:", acceptablePriceDiff);
        console.log("spotPrice:", spotPrice);
        console.log("twPrice:", twPrice);
        console.log("abs(spotPrice - twPrice):", spotPrice > twPrice ? spotPrice - twPrice : twPrice - spotPrice);
        console.log("acceptablePriceDiff:", acceptablePriceDiff);
        /////
        // check if the spot price is within the acceptable range
        return !(spotPrice >= twPrice - acceptablePriceDiff && spotPrice <= twPrice + acceptablePriceDiff);
    }

    // decimals is the decimals for the tokens which serves as unit price
    function getPrices() internal view returns (uint256 twPrice, uint256 spotPrice) {
        // get the spot price of the pool
        (uint160 sqrtPriceX96,,,,,,) = pool.slot0();

        uint256 decimals = assetIsToken0 ? decimals1 : decimals0;

        spotPrice = UniswapUtils.getQuoteFromSqrtRatioX96(sqrtPriceX96, uint128(10 ** decimals), assetIsToken0);

        twPrice = UniswapUtils.getTwap(pool, TWAP_PERIOD, uint128(10 ** decimals), assetIsToken0);
    }

    // Get total value locked in Uniswap V3 for a specific address in a specific pool
    function getUniswapV3Positions(address user)
        public
        view
        returns (Position memory position0, Position memory position1)
    {
        uint256 balance = positionManager.balanceOf(user);

        position0 = Position({token: address(poolToken0), value: 0});
        position1 = Position({token: address(poolToken1), value: 0});

        for (uint256 i = 0; i < balance; i++) {
            // Get the tokenId for each of the user's positions
            uint256 tokenId = positionManager.tokenOfOwnerByIndex(user, i);

            // Retrieve position details
            (,, address token0, address token1, uint24 fee,,,,,,,) = positionManager.positions(tokenId);

            // Get the pool address
            PoolAddress.PoolKey memory key = PoolAddress.getPoolKey(token0, token1, fee);

            // todo: save gas by storing the pool key (generated in the constructor) in the contract
            address computedPoolAddress = PoolAddress.computeAddress(pool.factory(), key);

            if (computedPoolAddress == address(pool)) {
                (uint160 sqrtPriceX96,,,,,,) = pool.slot0();

                (uint256 amount0, uint256 fee0, uint256 amount1, uint256 fee1) =
                    PositionValue.total(positionManager, tokenId, sqrtPriceX96);

                console.log("amount0", amount0);
                console.log("fee0", fee0);
                console.log("amount1", amount1);
                console.log("fee1", fee1);

                // Update the position values
                position0.value += amount0 + fee0.mulDiv(BASIS_POINT_SCALE - feeCutBasisPoint, BASIS_POINT_SCALE);

                position1.value += amount1 + fee1.mulDiv(BASIS_POINT_SCALE - feeCutBasisPoint, BASIS_POINT_SCALE);
            }
        }

        return (position0, position1);
    }
}
