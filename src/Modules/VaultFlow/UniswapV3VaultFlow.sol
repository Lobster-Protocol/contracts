// SPDX-License-Identifier: GPLv3
pragma solidity ^0.8.28;

import "forge-std/Test.sol";

import {IVaultFlowModule} from "../../interfaces/modules/IVaultFlowModule.sol";
import {INav} from "../../interfaces/modules/INav.sol";
import {IERC20} from "@openzeppelin/contracts/interfaces/IERC20.sol";
import {IERC20Metadata} from "@openzeppelin/contracts/interfaces/IERC20Metadata.sol";
import {IERC4626} from "@openzeppelin/contracts/interfaces/IERC4626.sol";
import {IUniswapV3PoolMinimal} from "../../interfaces/uniswapV3/IUniswapV3PoolMinimal.sol";
import {BaseOp, Op, BatchOp} from "../../interfaces/modules/IOpValidatorModule.sol";
import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
import {LobsterVault} from "../../../src/Vault/Vault.sol";
import {UniswapUtils, Position} from "../../libraries/uniswapV3/UniswapUtils.sol";
import {INonFungiblePositionManager} from "../../interfaces/uniswapV3/INonFungiblePositionManager.sol";
import {PositionValue} from "../../libraries/uniswapV3/PositionValue.sol";
import {PoolAddress} from "../../libraries/uniswapV3/PoolAddress.sol";
import {IUniswapV3RouterMinimal} from "../../interfaces/uniswapV3/IUniswapV3RouterMinimal.sol";

/**
 * @dev Basis points scale used for percentage calculations (100% = 10,000 basis points)
 */
uint16 constant BASIS_POINT_SCALE = 10_000;

/**
 * @title UniswapV3VaultFlow
 * @dev Contract that implements fee collection and NAV calculation for Uniswap V3 positions
 * in a LobsterVault. This module handles:
 * 1. Deposit/withdrawal flows with price volatility protection
 * 2. Total asset value calculation including active LP positions
 * 3. Fee distribution with configurable fee cut
 *
 * The contract integrates with Uniswap V3 pools and enforces volatility checks to protect
 * against potential arbitrage attacks during deposit and withdrawal operations.
 */
contract UniswapV3VaultFlow is IVaultFlowModule, INav {
    using Math for uint256;

    uint256 constant MAX_SLIPPAGE = 300; // 3% slippage (dev value)

    /**
     * @dev The percentage of fees generated by the vault's positions that will be kept by the protocol
     * Expressed in basis points (e.g., 1000 = 10%)
     */
    uint256 immutable feeCutBasisPoint;

    /**
     * @dev The Uniswap V3 pool this contract interacts with
     */
    IUniswapV3PoolMinimal public pool;

    /**
     * @dev The Uniswap V3 position manager
     */
    INonFungiblePositionManager public positionManager;

    /**
     * @dev The address of the Uniswap V3 router
     */
    address public router;

    address public feeCollector;

    /**
     * @dev Flag indicating if the asset used for valuation is token0 in the pool
     */
    bool private immutable assetIsToken0;

    /**
     * @dev The two tokens in the Uniswap V3 pool
     */
    IERC20 public immutable poolToken0;
    IERC20 public immutable poolToken1;

    /**
     * @dev The vault asset used for valuation
     */
    IERC20 public immutable vaultAsset;

    /**
     * @dev Decimal precision of each token in the pool
     */
    uint8 decimals0;
    uint8 decimals1;

    error ZeroAddress();

    /**
     * @dev Initializes the UniswapV3VaultFlow contract
     * @param _pool The Uniswap V3 pool this contract interacts with
     * @param positionManager_ The Uniswap V3 position manager for NFT positions
     * @param asset The address of the asset used for valuation (must be one of the pool tokens)
     * @param feeCutBasisPoint_ The percentage of fees to be kept by the protocol on uniswap fee collection (in basis points)
     */
    constructor(
        IUniswapV3PoolMinimal _pool,
        INonFungiblePositionManager positionManager_,
        address router_,
        address asset,
        address feeCollector_,
        uint256 feeCutBasisPoint_
    ) {
        if (feeCollector_ == address(0) || router_ == address(0)) {
            revert ZeroAddress();
        }

        pool = _pool;
        feeCollector = feeCollector_;

        // Verify that the asset is one of the pool tokens and store which one it is
        assetIsToken0 = address(_pool.token0()) == asset;
        require(
            assetIsToken0 || address(_pool.token1()) == asset,
            "UniswapV3VaultFlow: Neither token is the wanted asset"
        );

        vaultAsset = IERC20(asset);

        poolToken0 = IERC20(_pool.token0());
        poolToken1 = IERC20(_pool.token1());

        // Cache token decimals to avoid repeated external calls
        decimals0 = IERC20Metadata(address(poolToken0)).decimals();
        decimals1 = IERC20Metadata(address(poolToken1)).decimals();

        positionManager = positionManager_;
        router = router_;
        feeCutBasisPoint = feeCutBasisPoint_;
    }

    // /**
    //  * @inheritdoc IVaultFlowModule
    //  * @dev Handles the deposit flow with price volatility protection
    //  * - Checks that current price volatility is within acceptable bounds
    //  * - Transfers assets from caller to vault
    //  * - Mints shares to the receiver
    //  */
    function _deposit(
        address caller,
        address receiver,
        uint256 assets,
        uint256 shares
    ) external returns (bool success) {
        LobsterVault vault = LobsterVault(msg.sender);

        // Execute the deposit
        vault.safeTransferFrom(
            IERC20(vault.asset()),
            caller,
            address(vault),
            assets
        );
        vault.mintShares(receiver, shares);

        emit IERC4626.Deposit(caller, receiver, assets, shares);

        return true;
    }

    // /**
    //  * @inheritdoc IVaultFlowModule
    //  */
    function _withdraw(
        address caller,
        address receiver,
        address owner,
        uint256 assets,
        uint256 shares
    ) external returns (bool success) {
        LobsterVault vault = LobsterVault(msg.sender);

        if (caller != owner) {
            vault.spendAllowance(owner, caller, shares);
        }

        // If needed, withdraw the tokens we need from uniswap
        uint256 tokensCount = positionManager.balanceOf(address(vault));

        // Get the initial Vault balances
        uint256 initialToken0Balance = poolToken0.balanceOf(address(vault));
        uint256 initialToken1Balance = poolToken1.balanceOf(address(vault));

        // Get the shares ratio to burn so we can get the positions ratio to withdraw
        // if we withdraw x% of the shares, we need to withdraw x% of each position
        uint256 sharesRatioBp = shares.mulDiv(
            BASIS_POINT_SCALE,
            vault.totalSupply()
        );

        console.log(
            "shares: ",
            shares,
            "vault.totalSupply(): ",
            vault.totalSupply()
        );

        (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();

        // Aggregate all the fees to be cut
        uint256 allFee0 = 0;
        uint256 allFee1 = 0;
        uint256 totalToWithdraw0 = 0;
        uint256 totalToWithdraw1 = 0;

        for (uint256 i = 0; i < tokensCount; i++) {
            uint256 tokenId = positionManager.tokenOfOwnerByIndex(
                address(vault),
                i
            );

            // Get the position details
            // todo: merge with PositionValue.total to also get the token0 & token1 amounts and save gas:
            // - extract uint256 position0, uint256 fee0, uint256 position1, uint256 fee1 from the positions information
            (
                ,
                ,
                address token0,
                address token1,
                uint24 fee, // int24 tickLower, //int24 tickUpper,
                ,
                ,
                uint128 liquidity, //uint256 tokensOwed0, //uint256 tokensOwed1
                ,
                ,
                ,

            ) = positionManager.positions(tokenId);

            // Only take the positions that are in the pool
            PoolAddress.PoolKey memory key = PoolAddress.getPoolKey(
                token0,
                token1,
                fee
            );
            address computedPoolAddress = PoolAddress.computeAddress(
                pool.factory(),
                key
            );

            if (computedPoolAddress != address(pool)) {
                // Should not happen. Those positions would likely be lost
                continue; // skip this position
            }

            // Get the position value
            (
                uint256 position0,
                uint256 fee0,
                uint256 position1,
                uint256 fee1
            ) = PositionValue.total(positionManager, tokenId, sqrtPriceX96);

            // Save the fee ratio to withdraw
            allFee0 += fee0;
            allFee1 += fee1;
            totalToWithdraw0 += position0;
            totalToWithdraw1 += position1;

            console.log("shares ratio: ", sharesRatioBp);

            // Get the amounts to extract
            uint256 toWithdraw0 = position0.mulDiv(
                sharesRatioBp,
                BASIS_POINT_SCALE
            );
            uint256 toWithdraw1 = position1.mulDiv(
                sharesRatioBp,
                BASIS_POINT_SCALE
            );

            // Decrease the liquidity of the position
            INonFungiblePositionManager.DecreaseLiquidityParams memory params = INonFungiblePositionManager
                .DecreaseLiquidityParams({
                    tokenId: tokenId,
                    liquidity: liquidity,
                    // todo: are those values ok or do we need a slippage ?
                    amount0Min: toWithdraw0,
                    amount1Min: toWithdraw1,
                    deadline: block.timestamp
                });

            // Decrease liquidity
            BaseOp memory decreaseLiquidity = BaseOp({
                target: address(positionManager),
                value: 0,
                data: abi.encodeCall(
                    positionManager.decreaseLiquidity,
                    (params)
                )
            });

            vault.executeOp(Op(decreaseLiquidity, ""));

            // Collect if needed
            uint128 total0 = uint128(toWithdraw0 + fee0);
            uint128 total1 = uint128(toWithdraw1 + fee1);

            if (total0 > 0 || total1 > 0) {
                console.log("on va collecter les fees");
                BaseOp memory collectFees = BaseOp({
                    target: address(positionManager),
                    value: 0,
                    data: abi.encodeCall(
                        positionManager.collect,
                        (
                            INonFungiblePositionManager.CollectParams({
                                recipient: address(vault),
                                tokenId: tokenId,
                                amount0Max: uint128(total0),
                                amount1Max: uint128(total1)
                            })
                        )
                    )
                });
                vault.executeOp(Op(collectFees, ""));
            }
        }

        // Avoid reentrancy with some ERCs by burning before transfer
        vault.burnShares(owner, shares);

        // Compute fee cut
        uint256 feeCut0 = allFee0.mulDiv(feeCutBasisPoint, BASIS_POINT_SCALE);
        uint256 feeCut1 = allFee1.mulDiv(feeCutBasisPoint, BASIS_POINT_SCALE);

        // Total tokens to send to the user = Share of the initial vault balance + positions tokens
        uint256 valueToWithdraw0 = initialToken0Balance.mulDiv(
            sharesRatioBp,
            BASIS_POINT_SCALE
        ) + (totalToWithdraw0 - feeCut0);
        uint256 valueToWithdraw1 = initialToken1Balance.mulDiv(
            sharesRatioBp,
            BASIS_POINT_SCALE
        ) + (totalToWithdraw1 - feeCut1);

        console.log(
            "initialToken0Balance: ",
            initialToken0Balance,
            "initialToken1Balance: ",
            initialToken1Balance
        );
        console.log("feeCut0: ", feeCut0, "feeCut1: ", feeCut1);
        console.log(
            "valueToWithdraw0: ",
            valueToWithdraw0,
            "valueToWithdraw1: ",
            valueToWithdraw1
        );
        console.log(
            "token0 in vault: ",
            poolToken0.balanceOf(address(vault)),
            "token1 in vault: ",
            poolToken1.balanceOf(address(vault))
        );

        // Transfer the fees cut to fee collector
        // todo: mint shares instead ?
        console.log("fee collector: ", feeCollector);
        vault.safeTransfer(poolToken0, feeCollector, feeCut0);
        vault.safeTransfer(poolToken1, feeCollector, feeCut1);

        // Transfer the assets to the receiver
        vault.safeTransfer(poolToken0, receiver, valueToWithdraw0);
        vault.safeTransfer(poolToken1, receiver, valueToWithdraw1);

        emit IERC4626.Withdraw(caller, receiver, owner, assets, shares);

        return true;
    }

    /**
     * @inheritdoc INav
     * @dev Calculates the total value of assets in the calling vault
     * This includes:
     * - Direct token holdings
     * - Value locked in active Uniswap V3 positions
     * - Uncollected fees (minus the protocol fee cut)
     *
     * @return totalValue The total value of all assets, normalized to the vault's asset
     */
    function totalAssets() external view returns (uint256 totalValue) {
        // Assumes the caller is the vault
        return totalAssets_(LobsterVault(msg.sender));
    }

    /**
     * @dev Calculates the total value of assets for a specific vault
     * Same as totalAssets() but for an explicitly provided vault address
     *
     * @param vault The vault to calculate total assets for
     * @return totalValue The total value of the vault in the asset
     */
    function totalAssetsFor(
        LobsterVault vault
    ) external view returns (uint256 totalValue) {
        return totalAssets_(vault);
    }

    /**
     * @dev Common implementation logic for totalAssets() and totalAssetsFor()
     * Calculates the total value of all assets held by the vault, including:
     * - Direct token holdings
     * - Value locked in active Uniswap V3 positions
     * - Uncollected fees (minus the protocol fee cut)
     *
     * All values are normalized to the vault's asset token
     * @notice This functions converts the values to the vault's asset token using the spot price
     *
     * @param vault The vault to calculate total assets for
     * @return totalValue The total value of the vault in the asset
     */
    function totalAssets_(
        LobsterVault vault
    ) internal view returns (uint256 totalValue) {
        // Determine if the vault's asset is token0 or token1 in the pool
        bool isVaultAssetToken0 = address(poolToken0) ==
            LobsterVault(vault).asset();

        require(
            isVaultAssetToken0 ||
                address(poolToken1) == LobsterVault(vault).asset(),
            "None of the pool assets is the vault asset"
        );

        // Get the direct pool token balances owned by the vault
        uint256 amount0 = poolToken0.balanceOf(address(vault));
        uint256 amount1 = poolToken1.balanceOf(address(vault));

        // Get all the positions in the pool (including non-collected fees)
        (
            Position memory position0,
            Position memory position1
        ) = getAllUniswapV3Positions(address(vault));

        // Get the current spot price to convert between tokens
        (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();
        uint256 spotPrice = UniswapUtils.getQuoteFromSqrtRatioX96(
            sqrtPriceX96,
            uint128(10 ** (isVaultAssetToken0 ? decimals1 : decimals0)),
            isVaultAssetToken0
        );

        // Calculate total value by converting all holdings to the vault's asset
        if (isVaultAssetToken0) {
            // If vault's asset is token0, convert token1 to token0
            totalValue =
                amount0 +
                position0.value +
                position1.value.mulDiv(spotPrice, 10 ** decimals1);
        } else {
            // If vault's asset is token1, convert token0 to token1
            totalValue =
                amount1 +
                position1.value +
                position0.value.mulDiv(spotPrice, 10 ** decimals0);
        }
    }

    /**
     * @dev Calculates the total value of a user's Uniswap V3 positions in the specified pool
     * Includes both the principal token amounts and uncollected fees (minus the protocol fee cut)
     *
     * @param user The address whose positions to calculate
     * @return position0 The total value in token0 with fee adjustments
     * @return position1 The total value in token1 with fee adjustments
     */
    function getAllUniswapV3Positions(
        address user
    )
        public
        view
        returns (Position memory position0, Position memory position1)
    {
        // Get the total number of NFT positions owned by the user
        uint256 balance = positionManager.balanceOf(user);

        // Initialize position values
        position0 = Position({token: address(poolToken0), value: 0});
        position1 = Position({token: address(poolToken1), value: 0});

        // Iterate through all positions
        for (uint256 i = 0; i < balance; i++) {
            // Get the tokenId for the current position
            uint256 tokenId = positionManager.tokenOfOwnerByIndex(user, i);

            // Retrieve position details
            (
                ,
                ,
                address token0,
                address token1,
                uint24 fee,
                ,
                ,
                ,
                ,
                ,
                ,

            ) = positionManager.positions(tokenId);

            // Compute the pool address for this position
            PoolAddress.PoolKey memory key = PoolAddress.getPoolKey(
                token0,
                token1,
                fee
            );
            address computedPoolAddress = PoolAddress.computeAddress(
                pool.factory(),
                key
            );

            // Only count positions in the relevant pool
            if (computedPoolAddress == address(pool)) {
                // Get current price to value the position
                (uint160 sqrtPriceX96, , , , , , ) = pool.slot0();

                // Get total position value including fees
                (
                    uint256 amount0,
                    uint256 fee0,
                    uint256 amount1,
                    uint256 fee1
                ) = PositionValue.total(positionManager, tokenId, sqrtPriceX96);

                // Add principal amounts directly
                position0.value += amount0;
                position1.value += amount1;

                // For fees, apply the fee cut before adding
                position0.value += fee0.mulDiv(
                    BASIS_POINT_SCALE - feeCutBasisPoint,
                    BASIS_POINT_SCALE
                );
                position1.value += fee1.mulDiv(
                    BASIS_POINT_SCALE - feeCutBasisPoint,
                    BASIS_POINT_SCALE
                );
            }
        }

        return (position0, position1);
    }

    function maxDeposit(address) external pure returns (uint256) {
        revert("UniswapV3VaultFlow: maxDeposit not implemented");
    }

    function maxMint(address) external pure returns (uint256) {
        revert("UniswapV3VaultFlow: maxMint not implemented");
    }

    function maxWithdraw(address) external pure returns (uint256) {
        revert("UniswapV3VaultFlow: maxWithdraw not implemented");
    }

    function maxRedeem(address) external pure returns (uint256) {
        revert("UniswapV3VaultFlow: maxRedeem not implemented");
    }

    function previewDeposit(uint256) external pure returns (uint256) {
        revert("UniswapV3VaultFlow: previewDeposit not implemented");
    }

    function previewMint(uint256) external pure returns (uint256) {
        revert("UniswapV3VaultFlow: previewMint not implemented");
    }

    function previewWithdraw(uint256) external pure returns (uint256) {
        revert("UniswapV3VaultFlow: previewWithdraw not implemented");
    }

    function previewRedeem(uint256) external pure returns (uint256) {
        revert("UniswapV3VaultFlow: previewRedeem not implemented");
    }
}
