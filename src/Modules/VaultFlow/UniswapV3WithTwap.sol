// SPDX-License-Identifier: GPLv3
pragma solidity ^0.8.28;

import {IVaultFlowModule} from "../../interfaces/modules/IVaultFlowModule.sol";
import {INav} from "../../interfaces/modules/INav.sol";
import {IERC20} from "@openzeppelin/contracts/interfaces/IERC20.sol";
import {IERC20Metadata} from "@openzeppelin/contracts/interfaces/IERC20Metadata.sol";
import {IERC4626} from "@openzeppelin/contracts/interfaces/IERC4626.sol";
import {IUniswapV3PoolMinimal} from "../../interfaces/uniswapV3/IUniswapV3PoolMinimal.sol";
import {BaseOp, Op} from "../../interfaces/modules/IOpValidatorModule.sol";
import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
import {LobsterVault} from "../../../src/Vault/Vault.sol";
import {UniswapUtils, Position} from "../../libraries/uniswapV3/UniswapUtils.sol";
import {INonFungiblePositionManager} from "../../interfaces/uniswapV3/INonFungiblePositionManager.sol";
import {PositionValue} from "../../libraries/uniswapV3/PositionValue.sol";
import {PoolAddress} from "../../libraries/uniswapV3/PoolAddress.sol";

/**
 * @dev Basis points scale used for percentage calculations (100% = 10,000 basis points)
 */
uint16 constant BASIS_POINT_SCALE = 10_000;

/**
 * @title UniswapV3VaultFlow
 * @dev Contract that implements fee collection and NAV calculation for Uniswap V3 positions
 * in a LobsterVault. This module handles:
 * 1. Deposit/withdrawal flows with price volatility protection
 * 2. Total asset value calculation including active LP positions
 * 3. Fee distribution with configurable fee cut
 *
 * The contract integrates with Uniswap V3 pools and enforces volatility checks to protect
 * against potential arbitrage attacks during deposit and withdrawal operations.
 */
contract UniswapV3VaultFlow is IVaultFlowModule, INav {
    using Math for uint256;

    /**
     * @dev TWAP period used for price calculations (1 hour)
     */
    uint32 constant TWAP_PERIOD = 3600 seconds;
    
    /**
     * @dev The percentage of fees generated by the vault's positions that will be kept by the protocol
     * Expressed in basis points (e.g., 1000 = 10%)
     */
    uint256 immutable feeCutBasisPoint;
    
    /**
     * @dev The Uniswap V3 pool this contract interacts with
     */
    IUniswapV3PoolMinimal public pool;
    
    /**
     * @dev The Uniswap V3 position manager
     */
    INonFungiblePositionManager public positionManager;
    
    /**
     * @dev Flag indicating if the asset used for valuation is token0 in the pool
     */
    bool private immutable assetIsToken0;
    
    /**
     * @dev The two tokens in the Uniswap V3 pool
     */
    IERC20 public immutable poolToken0;
    IERC20 public immutable poolToken1;
    
    /**
     * @dev Decimal precision of each token in the pool
     */
    uint8 decimals0;
    uint8 decimals1;

    /**
     * @dev Maximum acceptable difference between spot price and TWAP price
     * This protects against flash loan attacks and high volatility events
     * Set to 1% (100 basis points)
     */
    uint256 public constant MAX_ACCEPTABLE_PRICE_DIFF_BASIS_POINT = 100;

    /**
     * @dev Initializes the UniswapV3VaultFlow contract
     * @param _pool The Uniswap V3 pool this contract interacts with
     * @param positionManager_ The Uniswap V3 position manager for NFT positions
     * @param asset The address of the asset used for valuation (must be one of the pool tokens)
     * @param feeCutBasisPoint_ The percentage of fees to be kept by the protocol on uniswap fee collection (in basis points)
     */
    constructor(
        IUniswapV3PoolMinimal _pool,
        INonFungiblePositionManager positionManager_,
        address asset,
        uint256 feeCutBasisPoint_
    ) {
        pool = _pool;

        // Verify that the asset is one of the pool tokens and store which one it is
        assetIsToken0 = address(_pool.token0()) == asset;
        require(
            assetIsToken0 || address(_pool.token1()) == asset, 
            "UniswapV3VaultFlow: Neither token is the wanted asset"
        );

        poolToken0 = IERC20(_pool.token0());
        poolToken1 = IERC20(_pool.token1());

        // Cache token decimals to avoid repeated external calls
        decimals0 = IERC20Metadata(address(poolToken0)).decimals();
        decimals1 = IERC20Metadata(address(poolToken1)).decimals();

        positionManager = positionManager_;
        feeCutBasisPoint = feeCutBasisPoint_;
    }

    /**
     * @inheritdoc IVaultFlowModule
     * @dev Handles the deposit flow with price volatility protection
     * - Checks that current price volatility is within acceptable bounds
     * - Transfers assets from caller to vault
     * - Mints shares to the receiver
     */
    function _deposit(
        address caller,
        address receiver,
        uint256 assets,
        uint256 shares
    )
        external
        returns (bool success)
    {
        (uint256 spotPrice, uint256 twPrice) = getPrices();

        // Refuse to deposit if the price is too volatile (spot price too far from TWAP)
        // This is a security measure to protect against potential arbitrage attacks
        requireLowVolatility(twPrice, spotPrice);

        LobsterVault vault = LobsterVault(msg.sender);

        // Execute the deposit
        vault.safeTransferFrom(IERC20(vault.asset()), caller, address(vault), assets);
        vault.mintShares(receiver, shares);

        emit IERC4626.Deposit(caller, receiver, assets, shares);

        return true;
    }

    /**
     * @inheritdoc IVaultFlowModule
     * @dev Currently not implemented - reverts with instruction to use PositionValue
     * In a future implementation, this would handle withdrawals with price volatility protection
     */
    function _withdraw(
        address, /* caller */
        address, /* receiver */
        address, /* owner */
        uint256, /* assets */
        uint256 /* shares */
    )
        external
        pure
        returns (bool /* success */ )
    {
        revert("use PositionValue");
        // - Check price volatility
        // - Apply slippage protection if needed
        // - Burn shares and transfer assets
    }

    /**
     * @inheritdoc INav
     * @dev Calculates the total value of assets in the calling vault
     * This includes:
     * - Direct token holdings
     * - Value locked in active Uniswap V3 positions
     * - Uncollected fees (minus the protocol fee cut)
     * 
     * @return totalValue The total value of all assets, normalized to the vault's asset
     */
    function totalAssets() external view returns (uint256 totalValue) {
        // Assumes the caller is the vault
        return totalAssets_(LobsterVault(msg.sender));
    }

    /**
     * @dev Calculates the total value of assets for a specific vault
     * Same as totalAssets() but for an explicitly provided vault address
     * 
     * @param vault The vault to calculate total assets for
     * @return totalValue The total value of the vault in the asset
     */
    function totalAssetsFor(LobsterVault vault) external view returns (uint256 totalValue) {
        return totalAssets_(vault);
    }

    /**
     * @dev Common implementation logic for totalAssets() and totalAssetsFor()
     * Calculates the total value of all assets held by the vault, including:
     * - Direct token holdings
     * - Value locked in active Uniswap V3 positions
     * - Uncollected fees (minus the protocol fee cut)
     * 
     * All values are normalized to the vault's asset token
     * 
     * @param vault The vault to calculate total assets for
     * @return totalValue The total value of the vault in the asset
     */
    function totalAssets_(LobsterVault vault) internal view returns (uint256 totalValue) {
        // Determine if the vault's asset is token0 or token1 in the pool
        bool isVaultAssetToken0 = address(poolToken0) == LobsterVault(vault).asset();
        
        require(
            isVaultAssetToken0 || address(poolToken1) == LobsterVault(vault).asset(),
            "None of the pool assets is the vault asset"
        );

        // Get the direct pool token balances owned by the vault
        uint256 amount0 = poolToken0.balanceOf(address(vault));
        uint256 amount1 = poolToken1.balanceOf(address(vault));

        // Get all the positions in the pool (including non-collected fees)
        (Position memory position0, Position memory position1) = getUniswapV3Positions(address(vault));

        // Get the current spot price to convert between tokens
        (uint160 sqrtPriceX96,,,,,,) = pool.slot0();
        uint256 spotPrice = UniswapUtils.getQuoteFromSqrtRatioX96(
            sqrtPriceX96, 
            uint128(10 ** (isVaultAssetToken0 ? decimals1 : decimals0)), 
            isVaultAssetToken0
        );
        
        // Calculate total value by converting all holdings to the vault's asset
        if (isVaultAssetToken0) {
            // If vault's asset is token0, convert token1 to token0
            totalValue = amount0 + position0.value + position1.value.mulDiv(spotPrice, 10 ** decimals1);
        } else {
            // If vault's asset is token1, convert token0 to token1
            totalValue = amount1 + position1.value + position0.value.mulDiv(spotPrice, 10 ** decimals0);
        }
    }

    /**
     * @dev Validates that the spot price is within acceptable range of the TWAP price
     * Reverts if price volatility exceeds the maximum acceptable difference
     * This protects against potential arbitrage attacks during high volatility
     * 
     * @param twapPrice The time-weighted average price
     * @param spotPrice The current spot price
     */
    function requireLowVolatility(uint256 twapPrice, uint256 spotPrice) internal pure {
        require(
            !tooMuchVolatility(twapPrice, spotPrice),
            "UniswapV3VaultOperations: Spot price is not within the acceptable range"
        );
    }

    /**
     * @dev Determines if price volatility exceeds acceptable bounds
     * Compares the difference between spot price and TWAP against the maximum allowed difference
     * 
     * @param twPrice The time-weighted average price
     * @param spotPrice The current spot price
     * @return bool True if volatility exceeds acceptable bounds, false otherwise
     */
    function tooMuchVolatility(
        uint256 twPrice, // amount of token1 needed for 1 token0
        uint256 spotPrice // amount of token1 needed for 1 token0
    )
        internal
        pure
        returns (bool)
    {
        // Calculate the maximum acceptable price difference based on TWAP
        uint256 acceptablePriceDiff = twPrice.mulDiv(MAX_ACCEPTABLE_PRICE_DIFF_BASIS_POINT, BASIS_POINT_SCALE);
        
        // Check if the spot price is outside the acceptable range
        // Returns true if volatility is too high
        return !(spotPrice >= twPrice - acceptablePriceDiff && spotPrice <= twPrice + acceptablePriceDiff);
    }

    /**
     * @dev Retrieves both the TWAP and spot prices from the Uniswap V3 pool
     * Returns prices normalized according to the decimals of the price unit token
     * 
     * @return twPrice The time-weighted average price over TWAP_PERIOD
     * @return spotPrice The current spot price from the pool
     */
    function getPrices() internal view returns (uint256 twPrice, uint256 spotPrice) {
        // Get the current spot price from the pool
        (uint160 sqrtPriceX96,,,,,,) = pool.slot0();

        // Use the decimals of the token that serves as the price unit
        uint256 decimals = assetIsToken0 ? decimals1 : decimals0;

        // Convert the sqrtPriceX96 to a human-readable price
        spotPrice = UniswapUtils.getQuoteFromSqrtRatioX96(sqrtPriceX96, uint128(10 ** decimals), assetIsToken0);

        // Get the time-weighted average price over TWAP_PERIOD
        twPrice = UniswapUtils.getTwap(pool, TWAP_PERIOD, uint128(10 ** decimals), assetIsToken0);
    }

    /**
     * @dev Calculates the total value of a user's Uniswap V3 positions in the specified pool
     * Includes both the principal token amounts and uncollected fees (minus the protocol fee cut)
     * 
     * @param user The address whose positions to calculate
     * @return position0 The total value in token0 with fee adjustments
     * @return position1 The total value in token1 with fee adjustments
     */
    function getUniswapV3Positions(address user)
        public
        view
        returns (Position memory position0, Position memory position1)
    {
        // Get the total number of NFT positions owned by the user
        uint256 balance = positionManager.balanceOf(user);

        // Initialize position values
        position0 = Position({token: address(poolToken0), value: 0});
        position1 = Position({token: address(poolToken1), value: 0});

        // Iterate through all positions
        for (uint256 i = 0; i < balance; i++) {
            // Get the tokenId for the current position
            uint256 tokenId = positionManager.tokenOfOwnerByIndex(user, i);

            // Retrieve position details
            (,, address token0, address token1, uint24 fee,,,,,,,) = positionManager.positions(tokenId);

            // Compute the pool address for this position
            PoolAddress.PoolKey memory key = PoolAddress.getPoolKey(token0, token1, fee);
            address computedPoolAddress = PoolAddress.computeAddress(pool.factory(), key);

            // Only count positions in the relevant pool
            if (computedPoolAddress == address(pool)) {
                // Get current price to value the position
                (uint160 sqrtPriceX96,,,,,,) = pool.slot0();

                // Get total position value including fees
                (uint256 amount0, uint256 fee0, uint256 amount1, uint256 fee1) =
                    PositionValue.total(positionManager, tokenId, sqrtPriceX96);

                // Add principal amounts directly
                position0.value += amount0;
                position1.value += amount1;
                
                // For fees, apply the fee cut before adding
                position0.value += fee0.mulDiv(BASIS_POINT_SCALE - feeCutBasisPoint, BASIS_POINT_SCALE);
                position1.value += fee1.mulDiv(BASIS_POINT_SCALE - feeCutBasisPoint, BASIS_POINT_SCALE);
            }
        }

        return (position0, position1);
    }
}