// SPDX-License-Identifier: GPLv3
pragma solidity ^0.8.28;

import {
    IVaultFlowModule,
    _DEPOSIT_OVERRIDE_ENABLED,
    _WITHDRAW_OVERRIDE_ENABLED,
    MAX_WITHDRAW_OVERRIDE_ENABLED,
    TWO_TOKEN_SUPPORT_ENABLED,
    PREVIEW_DEPOSIT_OVERRIDE_ENABLED,
    PREVIEW_MINT_OVERRIDE_ENABLED,
    PREVIEW_WITHDRAW_OVERRIDE_ENABLED,
    PREVIEW_REDEEM_OVERRIDE_ENABLED,
    ASSETS_SHARES_CONVERSION
} from "../../interfaces/modules/IVaultFlowModule.sol";
import {INav} from "../../interfaces/modules/INav.sol";
import {IERC20} from "@openzeppelin/contracts/interfaces/IERC20.sol";
import {IERC20Metadata} from "@openzeppelin/contracts/interfaces/IERC20Metadata.sol";
import {IERC4626} from "@openzeppelin/contracts/interfaces/IERC4626.sol";
import {IUniswapV3PoolMinimal} from "../../interfaces/uniswapV3/IUniswapV3PoolMinimal.sol";
import {BaseOp, Op} from "../../interfaces/modules/IOpValidatorModule.sol";
import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
import {LobsterVault} from "../../../src/Vault/Vault.sol";
import {Position} from "../../libraries/uniswapV3/UniswapUtils.sol";
import {INonFungiblePositionManager} from "../../interfaces/uniswapV3/INonFungiblePositionManager.sol";
import {PositionValue} from "../../libraries/uniswapV3/PositionValue.sol";
import {PoolAddress} from "../../libraries/uniswapV3/PoolAddress.sol";
import {BASIS_POINT_SCALE} from "../../Vault/Constants.sol";

/**
 * @title UniswapV3VaultFlow
 * @dev Contract that implements fee collection and NAV calculation for Uniswap V3 positions
 * in a LobsterVault. This module handles:
 * 1. Deposit/withdrawal flows with 2 tokens
 * 2. Total asset value calculation including active LP positions
 * 3. Fee distribution with configurable fee cut
 */
contract UniswapV3VaultFlow is IVaultFlowModule, INav {
    using Math for uint256;

    /**
     * @dev The percentage of fees generated by the vault's positions that will be kept by the protocol
     * Expressed in basis points (e.g., 1000 = 10%)
     */
    uint256 public immutable feeCutBasisPoint;

    /**
     * @dev The Uniswap V3 pool this contract interacts with
     */
    IUniswapV3PoolMinimal public pool;

    /**
     * @dev The Uniswap V3 position manager
     */
    INonFungiblePositionManager public positionManager;

    /**
     * @dev The address of the Uniswap V3 router
     */
    address public router;

    address public feeCollector;

    /**
     * @dev The two tokens in the Uniswap V3 pool which are the vault's assets
     */
    IERC20 public immutable vaultAsset0;
    IERC20 public immutable vaultAsset1;

    /**
     * @dev Decimal precision of each token in the pool
     */
    uint8 decimals0;
    uint8 decimals1;

    error ZeroAddress();

    /**
     * @dev Initializes the UniswapV3VaultFlow contract
     * @param _pool The Uniswap V3 pool this contract interacts with
     * @param positionManager_ The Uniswap V3 position manager for NFT positions
     * @param feeCutBasisPoint_ The percentage of fees to be kept by the protocol on uniswap fee collection (in basis points)
     */
    constructor(
        IUniswapV3PoolMinimal _pool,
        INonFungiblePositionManager positionManager_,
        address router_,
        address feeCollector_,
        uint256 feeCutBasisPoint_
    ) {
        if (feeCollector_ == address(0) || router_ == address(0)) {
            revert ZeroAddress();
        }

        pool = _pool;
        feeCollector = feeCollector_;

        vaultAsset0 = IERC20(_pool.token0());
        vaultAsset1 = IERC20(_pool.token1());

        // Cache token decimals to avoid repeated external calls
        decimals0 = IERC20Metadata(address(vaultAsset0)).decimals();
        decimals1 = IERC20Metadata(address(vaultAsset1)).decimals();

        positionManager = positionManager_;
        router = router_;
        feeCutBasisPoint = feeCutBasisPoint_;
    }

    /**
     * @inheritdoc IVaultFlowModule
     */
    function overridePolicy() external pure override returns (uint16) {
        return _DEPOSIT_OVERRIDE_ENABLED | _WITHDRAW_OVERRIDE_ENABLED | MAX_WITHDRAW_OVERRIDE_ENABLED
            | PREVIEW_DEPOSIT_OVERRIDE_ENABLED | PREVIEW_MINT_OVERRIDE_ENABLED | PREVIEW_WITHDRAW_OVERRIDE_ENABLED
            | PREVIEW_REDEEM_OVERRIDE_ENABLED | TWO_TOKEN_SUPPORT_ENABLED | ASSETS_SHARES_CONVERSION;
    }

    /**
     * @inheritdoc IVaultFlowModule
     * @dev Handles the deposit flow:
     * - Transfers 2 assets from caller to vault
     * - Mints shares to the receiver
     */
    function _deposit(
        address caller,
        address receiver,
        uint256 assets,
        uint256 shares
    )
        external
        returns (bool success)
    {
        LobsterVault vault = LobsterVault(msg.sender);

        (uint128 assets0, uint128 assets1) = unpackUint128(assets);

        // Execute the deposit
        if (assets0 > 0) {
            vault.safeTransferFrom(vaultAsset0, caller, address(vault), assets0);
        }
        if (assets0 > 1) {
            vault.safeTransferFrom(vaultAsset1, caller, address(vault), assets1);
        }

        vault.mintShares(receiver, shares);

        emit IERC4626.Deposit(caller, receiver, assets, shares);

        return true;
    }

    /**
     * @inheritdoc IVaultFlowModule
     * @dev Handles the withdrawal flow:
     * - Extract the tokens from the Uniswap V3 positions
     * - Burns shares from the caller
     * - Transfers the assets to the receiver
     *
     * @dev Note: This function assumes the caller is the vault itself
     */
    function _withdraw(
        address caller,
        address receiver,
        address owner,
        uint256, /* assets */
        uint256 shares
    )
        external
        returns (bool success)
    {
        LobsterVault vault = LobsterVault(msg.sender);

        if (caller != owner) {
            vault.spendAllowance(owner, caller, shares);
        }

        // If needed, withdraw the tokens we need from uniswap
        uint256 tokensCount = positionManager.balanceOf(address(vault));

        // Get the initial Vault balances
        uint256 initialToken0Balance = vaultAsset0.balanceOf(address(vault));
        uint256 initialToken1Balance = vaultAsset1.balanceOf(address(vault));

        // Get the shares ratio to burn so we can get the positions ratio to withdraw
        // if we withdraw x% of the shares, we need to withdraw x% of each position
        uint256 totalShares = vault.totalSupply();

        (uint160 sqrtPriceX96,,,,,,) = pool.slot0();

        // Aggregate all the fees to be cut
        uint256 allCollectedFee0 = 0;
        uint256 allCollectedFee1 = 0;
        uint256 totalWithdrawnFromPosition0 = 0;
        uint256 totalWithdrawnFromPosition1 = 0;

        for (uint256 i = 0; i < tokensCount; ++i) {
            uint256 tokenId = positionManager.tokenOfOwnerByIndex(address(vault), i);

            // Get the position details
            // todo: merge with PositionValue.total to also get the token0 & token1 amounts and save gas:
            // - extract uint256 position0, uint256 fee0, uint256 position1, uint256 fee1 from the positions information
            (
                ,
                ,
                address token0,
                address token1,
                uint24 fee, // int24 tickLower, //int24 tickUpper,
                ,
                ,
                uint128 liquidity, //uint256 tokensOwed0, //uint256 tokensOwed1
                ,
                ,
                ,
            ) = positionManager.positions(tokenId);

            // Only take the positions that are in the pool
            PoolAddress.PoolKey memory key = PoolAddress.getPoolKey(token0, token1, fee);
            address computedPoolAddress = PoolAddress.computeAddress(pool.factory(), key);

            if (computedPoolAddress != address(pool)) {
                // Should not happen. Those positions would likely be lost
                continue; // skip this position
            }

            // Get the position value
            (uint256 position0, uint256 fee0, uint256 position1, uint256 fee1) =
                PositionValue.total(positionManager, tokenId, sqrtPriceX96);

            // Get the amounts to extract
            uint256 toWithdraw0 = position0.mulDiv(shares, totalShares);
            uint256 toWithdraw1 = position1.mulDiv(shares, totalShares);
            allCollectedFee0 += fee0;
            allCollectedFee1 += fee1;
            totalWithdrawnFromPosition0 += toWithdraw0;
            totalWithdrawnFromPosition1 += toWithdraw1;

            if (toWithdraw0 > 0 || toWithdraw1 > 0) {
                // Decrease the liquidity of the position
                INonFungiblePositionManager.DecreaseLiquidityParams memory params = INonFungiblePositionManager
                    .DecreaseLiquidityParams({
                    tokenId: tokenId,
                    liquidity: liquidity,
                    // todo: are those values ok or do we need a slippage ?
                    amount0Min: toWithdraw0,
                    amount1Min: toWithdraw1,
                    deadline: block.timestamp
                });

                // Decrease liquidity
                BaseOp memory decreaseLiquidity = BaseOp({
                    target: address(positionManager),
                    value: 0,
                    data: abi.encodeCall(positionManager.decreaseLiquidity, (params))
                });

                vault.executeOp(Op(decreaseLiquidity, ""));
            }

            // Collect if needed
            uint128 total0 = uint128(toWithdraw0 + fee0);
            uint128 total1 = uint128(toWithdraw1 + fee1);

            if (total0 > 0 || total1 > 0) {
                BaseOp memory collectFees = BaseOp({
                    target: address(positionManager),
                    value: 0,
                    data: abi.encodeCall(
                        positionManager.collect,
                        (
                            INonFungiblePositionManager.CollectParams({
                                recipient: address(vault),
                                tokenId: tokenId,
                                amount0Max: uint128(total0),
                                amount1Max: uint128(total1)
                            })
                        )
                    )
                });
                vault.executeOp(Op(collectFees, ""));
            }
        }

        // Avoid reentrancy with some ERCs by burning before transfer
        vault.burnShares(owner, shares);

        // Compute fee cut
        uint256 feeCut0 = allCollectedFee0.mulDiv(feeCutBasisPoint, BASIS_POINT_SCALE);
        uint256 feeCut1 = allCollectedFee1.mulDiv(feeCutBasisPoint, BASIS_POINT_SCALE);

        uint256 valueToWithdraw0 = totalWithdrawnFromPosition0
        // todo: merge the mulDivs
        + initialToken0Balance.mulDiv(shares, totalShares) + (allCollectedFee0 - feeCut0).mulDiv(shares, totalShares);

        uint256 valueToWithdraw1 = totalWithdrawnFromPosition1
        // todo: merge the mulDivs
        + initialToken1Balance.mulDiv(shares, totalShares) + (allCollectedFee1 - feeCut1).mulDiv(shares, totalShares);

        // Transfer the fees cut to fee collector
        // todo: mint shares instead
        if (feeCut0 > 0) vault.safeTransfer(vaultAsset0, feeCollector, feeCut0);
        if (feeCut1 > 0) vault.safeTransfer(vaultAsset1, feeCollector, feeCut1);
        if (feeCut0 > 0 || feeCut1 > 0) {
            // todo: emit fee collection event
        }

        // Transfer the assets to the receiver
        if (valueToWithdraw0 > 0) {
            vault.safeTransfer(vaultAsset0, receiver, valueToWithdraw0);
        }
        if (valueToWithdraw1 > 0) {
            vault.safeTransfer(vaultAsset1, receiver, valueToWithdraw1);
        }

        uint256 withdrawnAssets = packUint128(uint128(valueToWithdraw0), uint128(valueToWithdraw1));

        emit IERC4626.Withdraw(caller, receiver, owner, withdrawnAssets, shares);

        return true;
    }

    /**
     * @inheritdoc INav
     * @dev Calculates the total value of assets in the calling vault
     * This includes:
     * - Direct token holdings
     * - Value locked in active Uniswap V3 positions
     * - Uncollected fees (minus the protocol fee cut)
     * @dev Note: This function assumes the caller is the vault itself
     *
     * @return totalValue The total value of assets in the vault packed as a single uint256 = (token0Value << 128) | token1Value
     */
    function totalAssets() external view returns (uint256 totalValue) {
        // Assumes the caller is the vault

        (uint256 totalValue0, uint256 totalValue1) = totalVaultAssets_(LobsterVault(msg.sender));

        // Pack the two uint128 values into a single uint256
        totalValue = packUint128(uint128(totalValue0), uint128(totalValue1));
    }

    /**
     * @dev Calculates the total value of assets for a specific vault
     *
     * @dev This function only uses the uniswap position on the registered pool and
     * the vault balances to calculate the total value in the vault.
     *
     * @param vault The vault to calculate total assets for
     * @return totalValue0 The total value of token0 owned by the vault
     * @return totalValue1 The total value of token1 owned by the vault
     */
    function totalAssetsFor(LobsterVault vault) external view returns (uint256 totalValue0, uint256 totalValue1) {
        return totalVaultAssets_(vault);
    }

    /**
     * @dev Common implementation logic for totalAssets() and totalAssetsFor()
     * Calculates the total value of all assets held by the vault, including:
     * - Direct token holdings
     * - Value locked in active Uniswap V3 positions
     * - Uncollected fees (minus the protocol fee cut)
     *
     * @param vault The vault to calculate total assets for
     * @return value1 The total value of token0 in the vault
     * @return value2 The total value of token1 in the vault
     */
    function totalVaultAssets_(LobsterVault vault) internal view returns (uint256 value1, uint256 value2) {
        // Get the direct pool token balances owned by the vault
        uint256 amount0 = vaultAsset0.balanceOf(address(vault));
        uint256 amount1 = vaultAsset1.balanceOf(address(vault));

        // Get all the positions in the pool (including non-collected fees)
        (
            Position memory position0, // contains fees
            Position memory position1 // contains fees
        ) = getAllUniswapV3Positions(address(vault));

        return (amount0 + position0.value, amount1 + position1.value);
    }

    /**
     * @dev Calculates the total value of a user's Uniswap V3 positions in the specified pool
     * Includes both the principal token amounts and uncollected fees (minus the protocol fee cut)
     *
     * @param user The address whose positions to calculate
     * @return position0 The total value in token0 with fee adjustments
     * @return position1 The total value in token1 with fee adjustments
     */
    function getAllUniswapV3Positions(address user)
        public
        view
        returns (Position memory position0, Position memory position1)
    {
        // Get the total number of NFT positions owned by the user
        uint256 balance = positionManager.balanceOf(user);

        // Initialize position values
        position0 = Position({token: address(vaultAsset0), value: 0});
        position1 = Position({token: address(vaultAsset1), value: 0});

        // Iterate through all positions
        for (uint256 i = 0; i < balance; i++) {
            // Get the tokenId for the current position
            uint256 tokenId = positionManager.tokenOfOwnerByIndex(user, i);

            // Retrieve position details
            (,, address token0, address token1, uint24 fee,,,,,,,) = positionManager.positions(tokenId);

            // Compute the pool address for this position
            PoolAddress.PoolKey memory key = PoolAddress.getPoolKey(token0, token1, fee);
            address computedPoolAddress = PoolAddress.computeAddress(pool.factory(), key);

            // Only count positions in the relevant pool
            if (computedPoolAddress == address(pool)) {
                // Get current price to value the position
                (uint160 sqrtPriceX96,,,,,,) = pool.slot0();

                // Get total position value including fees
                (uint256 amount0, uint256 fee0, uint256 amount1, uint256 fee1) =
                    PositionValue.total(positionManager, tokenId, sqrtPriceX96);

                // Add principal amounts directly
                position0.value += amount0;
                position1.value += amount1;

                // For fees, apply the fee cut before adding
                position0.value += fee0.mulDiv(BASIS_POINT_SCALE - feeCutBasisPoint, BASIS_POINT_SCALE);
                position1.value += fee1.mulDiv(BASIS_POINT_SCALE - feeCutBasisPoint, BASIS_POINT_SCALE);
            }
        }

        return (position0, position1);
    }

    function maxDeposit(address) external pure returns (uint256) {
        revert("UniswapV3VaultFlow: maxDeposit not implemented");
    }

    function maxMint(address) external pure returns (uint256) {
        revert("UniswapV3VaultFlow: maxMint not implemented");
    }

    // assume msg.sender is the vault
    function maxWithdraw(address owner) external view returns (uint256 maxValuesPacked) {
        return _convertToAssets(LobsterVault(msg.sender).balanceOf(owner), Math.Rounding.Floor);
    }

    function maxRedeem(address) external pure returns (uint256) {
        revert("UniswapV3VaultFlow: maxRedeem not implemented");
    }

    function previewDeposit(uint256 assets) public view virtual returns (uint256 shares) {
        return _convertToShares(assets, Math.Rounding.Floor);
    }

    function previewMint(uint256 shares) public view virtual returns (uint256 packedAssets) {
        return _convertToAssets(shares, Math.Rounding.Ceil);
    }

    // assume msg.sender is vault
    function previewWithdraw(uint256 assets) public view returns (uint256 shares) {
        return _convertToShares(assets, Math.Rounding.Ceil);
    }

    function previewRedeem(uint256 shares) external view returns (uint256) {
        return _convertToAssets(shares, Math.Rounding.Floor);
    }

    /**
     * @dev See {IERC4626-convertToShares}. - returns theamount of shares using the limiting token
     */
    function convertToShares(uint256 assets) public view returns (uint256) {
        return _convertToShares(assets, Math.Rounding.Floor);
    }

    /**
     * @dev See {IERC4626-convertToAssets}.
     */
    function convertToAssets(uint256 shares) external view returns (uint256) {
        return _convertToAssets(shares, Math.Rounding.Floor);
    }

    /**
     * @dev Internal conversion function (from assets to shares) with support for rounding direction.
     * returns the amount of shares using the limiting token
     */
    function _convertToShares(uint256 assets, Math.Rounding rounding) internal view virtual returns (uint256) {
        // Todo: fix this fcking fct
        uint256 sharesSupply = LobsterVault(msg.sender).totalSupply();
        uint256 decimalsOffset = LobsterVault(msg.sender).decimalsOffset();
        (uint256 totalAssets0, uint256 totalAssets1) = totalVaultAssets_(LobsterVault(msg.sender));

        (uint256 asset0, uint256 asset1) = unpackUint128(assets);

        uint256 shares0 = asset0.mulDiv(sharesSupply + 10 ** decimalsOffset, totalAssets0 + 1, rounding);
        uint256 shares1 = asset1.mulDiv(sharesSupply + 10 ** decimalsOffset, totalAssets1 + 1, rounding);

        // return the minimal value
        return shares0 > shares1 ? shares0 : shares1;
    }

    /**
     * @dev Internal conversion function (from shares to assets) with support for rounding direction.
     */
    function _convertToAssets(uint256 shares, Math.Rounding rounding) internal view virtual returns (uint256) {
        uint256 sharesSupply = LobsterVault(msg.sender).totalSupply();
        uint256 decimalsOffset = LobsterVault(msg.sender).decimalsOffset();
        (uint256 totalAssets0, uint256 totalAssets1) = totalVaultAssets_(LobsterVault(msg.sender));

        uint256 asset0 = shares.mulDiv(totalAssets0 + 1, sharesSupply + 10 ** decimalsOffset, rounding);
        uint256 asset1 = shares.mulDiv(totalAssets1 + 1, sharesSupply + 10 ** decimalsOffset, rounding);

        return packUint128(uint128(asset0), uint128(asset1));
    }

    // Pack two uint128 values into a single uint256
    // (val1 << 128) | val2
    function packUint128(uint128 a, uint128 b) internal pure returns (uint256 packed) {
        packed = (uint256(a) << 128) | uint256(b);
    }

    function unpackUint128(uint256 packed) internal pure returns (uint128 a, uint128 b) {
        a = uint128(packed >> 128);
        b = uint128(packed);
    }
}
