// SPDX-License-Identifier: GPLv3
pragma solidity ^0.8.28;

import "forge-std/Test.sol";

import {IVaultFlowModule} from "../../interfaces/modules/IVaultFlowModule.sol";
import {INav} from "../../interfaces/modules/INav.sol";
import {IERC20} from "@openzeppelin/contracts/interfaces/IERC20.sol";
import {IERC20Metadata} from "@openzeppelin/contracts/interfaces/IERC20Metadata.sol";
import {IERC4626} from "@openzeppelin/contracts/interfaces/IERC4626.sol";
import {IUniswapV3PoolMinimal} from "../../interfaces/uniswapV3/IUniswapV3PoolMinimal.sol";
import {BaseOp, Op, BatchOp} from "../../interfaces/modules/IOpValidatorModule.sol";
import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
import {LobsterVault} from "../../../src/Vault/Vault.sol";
import {UniswapUtils, Position} from "../../libraries/uniswapV3/UniswapUtils.sol";
import {INonFungiblePositionManager} from "../../interfaces/uniswapV3/INonFungiblePositionManager.sol";
import {PositionValue} from "../../libraries/uniswapV3/PositionValue.sol";
import {PoolAddress} from "../../libraries/uniswapV3/PoolAddress.sol";
import {IUniswapV3RouterMinimal} from "../../interfaces/uniswapV3/IUniswapV3RouterMinimal.sol";

/**
 * @dev Basis points scale used for percentage calculations (100% = 10,000 basis points)
 */
uint16 constant BASIS_POINT_SCALE = 10_000;

/**
 * @title UniswapV3VaultFlow
 * @dev Contract that implements fee collection and NAV calculation for Uniswap V3 positions
 * in a LobsterVault. This module handles:
 * 1. Deposit/withdrawal flows with price volatility protection
 * 2. Total asset value calculation including active LP positions
 * 3. Fee distribution with configurable fee cut
 *
 * The contract integrates with Uniswap V3 pools and enforces volatility checks to protect
 * against potential arbitrage attacks during deposit and withdrawal operations.
 */
contract UniswapV3VaultFlow is IVaultFlowModule, INav {
    using Math for uint256;

    /**
     * @dev TWAP period used for price calculations (1 hour)
     */
    uint32 constant TWAP_PERIOD = 3600 seconds;

    uint256 constant MAX_SLIPPAGE = 30; // 0.3% slippage

    /**
     * @dev The percentage of fees generated by the vault's positions that will be kept by the protocol
     * Expressed in basis points (e.g., 1000 = 10%)
     */
    uint256 immutable feeCutBasisPoint;

    /**
     * @dev The Uniswap V3 pool this contract interacts with
     */
    IUniswapV3PoolMinimal public pool;

    /**
     * @dev The Uniswap V3 position manager
     */
    INonFungiblePositionManager public positionManager;

    /**
     * @dev The address of the Uniswap V3 router
     */
    address public router;

    /**
     * @dev Flag indicating if the asset used for valuation is token0 in the pool
     */
    bool private immutable assetIsToken0;

    /**
     * @dev The two tokens in the Uniswap V3 pool
     */
    IERC20 public immutable poolToken0;
    IERC20 public immutable poolToken1;

    /**
     * @dev The vault asset used for valuation
     */
    IERC20 public immutable vaultAsset;

    /**
     * @dev Decimal precision of each token in the pool
     */
    uint8 decimals0;
    uint8 decimals1;

    /**
     * @dev Maximum acceptable difference between spot price and TWAP price
     * This protects against flash loan attacks and high volatility events
     * Set to 1% (100 basis points)
     */
    uint256 public constant MAX_ACCEPTABLE_PRICE_DIFF_BASIS_POINT = 100;

    /**
     * @dev Initializes the UniswapV3VaultFlow contract
     * @param _pool The Uniswap V3 pool this contract interacts with
     * @param positionManager_ The Uniswap V3 position manager for NFT positions
     * @param asset The address of the asset used for valuation (must be one of the pool tokens)
     * @param feeCutBasisPoint_ The percentage of fees to be kept by the protocol on uniswap fee collection (in basis points)
     */
    constructor(
        IUniswapV3PoolMinimal _pool,
        INonFungiblePositionManager positionManager_,
        address router_,
        address asset,
        uint256 feeCutBasisPoint_
    ) {
        pool = _pool;

        // Verify that the asset is one of the pool tokens and store which one it is
        assetIsToken0 = address(_pool.token0()) == asset;
        require(
            assetIsToken0 || address(_pool.token1()) == asset, "UniswapV3VaultFlow: Neither token is the wanted asset"
        );

        vaultAsset = IERC20(asset);

        poolToken0 = IERC20(_pool.token0());
        poolToken1 = IERC20(_pool.token1());

        // Cache token decimals to avoid repeated external calls
        decimals0 = IERC20Metadata(address(poolToken0)).decimals();
        decimals1 = IERC20Metadata(address(poolToken1)).decimals();

        positionManager = positionManager_;
        router = router_;
        feeCutBasisPoint = feeCutBasisPoint_;
    }

    /**
     * @inheritdoc IVaultFlowModule
     * @dev Handles the deposit flow with price volatility protection
     * - Checks that current price volatility is within acceptable bounds
     * - Transfers assets from caller to vault
     * - Mints shares to the receiver
     */
    function _deposit(
        address caller,
        address receiver,
        uint256 assets,
        uint256 shares
    )
        external
        returns (bool success)
    {
        (uint256 spotPrice, uint256 twPrice) = getPrices();

        // Refuse to deposit if the price is too volatile (spot price too far from TWAP)
        // This is a security measure to protect against potential arbitrage attacks
        requireLowVolatility(twPrice, spotPrice);

        LobsterVault vault = LobsterVault(msg.sender);

        // Execute the deposit
        vault.safeTransferFrom(IERC20(vault.asset()), caller, address(vault), assets);
        vault.mintShares(receiver, shares);

        emit IERC4626.Deposit(caller, receiver, assets, shares);

        return true;
    }

    /**
     * @inheritdoc IVaultFlowModule
     */
    function _withdraw(
        address caller,
        address receiver,
        address owner,
        uint256 assets,
        uint256 shares
    )
        external
        returns (bool success)
    {
        console.log("initial assets", assets);
        console.log("initial shares", shares);

        LobsterVault vault = LobsterVault(msg.sender);
        IERC20 asset = IERC20(vault.asset());

        // Assumes the caller is the vault
        if (caller != owner) {
            vault.spendAllowance(owner, caller, shares);
        }
        // Check volatility
        (uint256 twPrice, uint256 spotPrice) = getPrices();

        // if the volatility is too high and the withdrawer might be advantaged (arbitrage) so we create a slippage to protect the vault
        if (tooMuchVolatility(twPrice, spotPrice) == true && spotPrice > twPrice) {
            /*
                 If spotPrice > twPrice, the vault tvl will be over evaluated and during by totalAssets_,
                 making the vault transfer more tokens than necessary.
                 This snippets aims to fix this
                 // todo: We can also just refuse the withdrawal and add a specific function to withdraw with an explicit acceptance of the slippage (with a signed message)
             */

            // Estimate the slippage
            uint256 slippageDiffBasisPoint = twPrice.mulDiv(BASIS_POINT_SCALE, spotPrice); // < 10_000 since spotPrice > twPrice

            // reduce the withdrawn asset amount accordingly
            assets = assets.mulDiv(slippageDiffBasisPoint, BASIS_POINT_SCALE);
        }

        console.log("vaultAsset.balanceOf(address(vault)) < assets", vaultAsset.balanceOf(address(vault)) < assets);

        // If needed, withdraw the tokens we need from uniswap
        uint256 tokensCount = positionManager.balanceOf(address(vault));
        if (tokensCount > 0 && vaultAsset.balanceOf(address(vault)) < assets) {
            // Get the shares ratio to burn so we can get the positions ratio to withdraw
            // if we withdraw x% of the shares, we need to withdraw x% of each position
            uint256 sharesRatio = shares.mulDiv(BASIS_POINT_SCALE, vault.totalSupply());

            uint256 amount0Collected = 0;
            uint256 amount1Collected = 0;

            // List of all operations to execute
            BaseOp[] memory ops = new BaseOp[](2 * tokensCount + 1); // (Decrease + Collect) * nb of positions + 1 for the swap to asset

            uint256 token0Before = poolToken0.balanceOf(address(vault));
            uint256 token1Before = poolToken1.balanceOf(address(vault));
            (uint160 sqrtPriceX96,,,,,,) = pool.slot0();

            // Aggregate all the fees to be cut
            uint256 allFeesCut0 = 0;
            uint256 allFeesCut1 = 0;

            for (uint256 i = 0; i < tokensCount; i++) {
                console.log("i", i);
                uint256 tokenId = positionManager.tokenOfOwnerByIndex(address(vault), i);

                // Get the position details
                (
                    ,
                    ,
                    address token0,
                    address token1,
                    uint24 fee,
                    int24 tickLower,
                    int24 tickUpper,
                    uint128 liquidity,
                    ,
                    ,
                    uint256 tokensOwed0,
                    uint256 tokensOwed1
                ) = positionManager.positions(tokenId);

                // Only take the positions that are in the pool
                PoolAddress.PoolKey memory key = PoolAddress.getPoolKey(token0, token1, fee);
                address computedPoolAddress = PoolAddress.computeAddress(pool.factory(), key);

                if (computedPoolAddress != address(pool)) {
                    continue; // skip this position
                }

                // Get the position value
                (uint256 position0, uint256 fee0, uint256 position1, uint256 fee1) =
                    PositionValue.total(positionManager, tokenId, sqrtPriceX96);

                // Get the amounts to extract
                uint256 toWithdraw0 = position0.mulDiv(sharesRatio, BASIS_POINT_SCALE);
                uint256 toWithdraw1 = position1.mulDiv(sharesRatio, BASIS_POINT_SCALE);
                // For fees, apply the fee cut before adding
                uint256 toWithdrawFee0 = fee0.mulDiv(sharesRatio, BASIS_POINT_SCALE).mulDiv(
                    BASIS_POINT_SCALE - feeCutBasisPoint, BASIS_POINT_SCALE
                );
                uint256 toWithdrawFee1 = fee1.mulDiv(sharesRatio, BASIS_POINT_SCALE).mulDiv(
                    BASIS_POINT_SCALE - feeCutBasisPoint, BASIS_POINT_SCALE
                );

                // Decrease the liquidity of the position
                INonFungiblePositionManager.DecreaseLiquidityParams memory params = INonFungiblePositionManager
                    .DecreaseLiquidityParams({
                    tokenId: tokenId,
                    liquidity: liquidity,
                    amount0Min: toWithdraw0,
                    amount1Min: toWithdraw1,
                    deadline: block.timestamp + 1 hours
                });

                // Decrease liquidity
                BaseOp memory decreaseLiquidity = BaseOp({
                    target: address(positionManager),
                    value: 0,
                    data: abi.encodeCall(positionManager.decreaseLiquidity, (params))
                });

                // Collect the fees
                BaseOp memory collectFees = BaseOp({
                    target: address(positionManager),
                    value: 0,
                    data: abi.encodeCall(
                        positionManager.collect,
                        (
                            INonFungiblePositionManager.CollectParams({
                                recipient: address(vault),
                                tokenId: tokenId,
                                amount0Max: uint128(toWithdrawFee0 + fee0),
                                amount1Max: uint128(toWithdrawFee1 + fee1)
                            })
                        )
                    )
                });

                ops[2 * i] = decreaseLiquidity;
                ops[2 * i + 1] = collectFees;
            }

            // Swap the tokens for the vault asset
            uint256 amountIn = assetIsToken0
                ? token1Before - poolToken1.balanceOf(address(vault))
                : token0Before - poolToken0.balanceOf(address(vault));
            uint256 quote = UniswapUtils.getQuoteFromSqrtRatioX96(
                sqrtPriceX96, uint128(10 ** (assetIsToken0 ? decimals1 : decimals0)), assetIsToken0
            );
            uint256 amountOutWithSlippage =
                amountIn.mulDiv(quote * (BASIS_POINT_SCALE - MAX_SLIPPAGE), BASIS_POINT_SCALE);
            console.log("amountOutWithSlippage", amountOutWithSlippage, "quote", quote);
            ops[2 * tokensCount] = BaseOp({
                target: router,
                value: 0,
                data: abi.encodeCall(
                    IUniswapV3RouterMinimal.exactInputSingle,
                    (
                        IUniswapV3RouterMinimal.ExactInputSingleParams({
                            tokenIn: assetIsToken0 ? address(poolToken1) : address(poolToken0),
                            tokenOut: vault.asset(),
                            fee: pool.fee(),
                            recipient: address(vault),
                            deadline: block.timestamp + 1 hours,
                            amountIn: amountIn,
                            amountOutMinimum: amountOutWithSlippage,
                            sqrtPriceLimitX96: 0
                        })
                    )
                )
            });

            BatchOp memory batchedOps = BatchOp({
                ops: ops,
                validationData: "" // No validation data needed, caller will be the VaultFlow module
            });

            vault.executeOpBatch(batchedOps);
        }

        console.log("final tokenA: ", poolToken0.balanceOf(address(vault)));
        console.log("final tokenB: ", poolToken1.balanceOf(address(vault)));

        /**
         * - collect fees (including cut)
         * - swap all tokens for the vault asset
         * - Burn shares
         * - transfer to receiver
         * - transfer fees cut to the fee collector
         */

        // If _asset is ERC-777, `transfer` can trigger a reentrancy AFTER the transfer happens through the
        // `tokensReceived` hook. On the other hand, the `tokensToSend` hook, that is triggered before the transfer,
        // calls the vault, which is assumed not malicious.
        //
        // Conclusion: we need to do the transfer after the burn so that any reentrancy would happen after the
        // shares are burned and after the assets are transferred, which is a valid state.
        vault.burnShares(owner, shares);
        // Transfer the fees cut to the fee collector

        // Transfer the assets to the receiver
        vault.safeTransfer(asset, receiver, assets);

        emit IERC4626.Withdraw(caller, receiver, owner, assets, shares);

        return true;
    }

    /**
     * @inheritdoc IVaultFlowModule
     */
    function maxWithdraw(address owner) external view returns (uint256 maxAssets) {
        // Get the

        // // Assumes the caller is the vault
        // return _convertToAssets(balanceOf(owner), Math.Rounding.Floor);
    }

    /**
     * @inheritdoc INav
     * @dev Calculates the total value of assets in the calling vault
     * This includes:
     * - Direct token holdings
     * - Value locked in active Uniswap V3 positions
     * - Uncollected fees (minus the protocol fee cut)
     *
     * @return totalValue The total value of all assets, normalized to the vault's asset
     */
    function totalAssets() external view returns (uint256 totalValue) {
        // Assumes the caller is the vault
        return totalAssets_(LobsterVault(msg.sender));
    }

    /**
     * @dev Calculates the total value of assets for a specific vault
     * Same as totalAssets() but for an explicitly provided vault address
     *
     * @param vault The vault to calculate total assets for
     * @return totalValue The total value of the vault in the asset
     */
    function totalAssetsFor(LobsterVault vault) external view returns (uint256 totalValue) {
        return totalAssets_(vault);
    }

    /**
     * @dev Common implementation logic for totalAssets() and totalAssetsFor()
     * Calculates the total value of all assets held by the vault, including:
     * - Direct token holdings
     * - Value locked in active Uniswap V3 positions
     * - Uncollected fees (minus the protocol fee cut)
     *
     * All values are normalized to the vault's asset token
     * @notice This functions converts the values to the vault's asset token using the spot price
     *
     * @param vault The vault to calculate total assets for
     * @return totalValue The total value of the vault in the asset
     */
    function totalAssets_(LobsterVault vault) internal view returns (uint256 totalValue) {
        // Determine if the vault's asset is token0 or token1 in the pool
        bool isVaultAssetToken0 = address(poolToken0) == LobsterVault(vault).asset();

        require(
            isVaultAssetToken0 || address(poolToken1) == LobsterVault(vault).asset(),
            "None of the pool assets is the vault asset"
        );

        // Get the direct pool token balances owned by the vault
        uint256 amount0 = poolToken0.balanceOf(address(vault));
        uint256 amount1 = poolToken1.balanceOf(address(vault));

        // Get all the positions in the pool (including non-collected fees)
        (Position memory position0, Position memory position1) = getAllUniswapV3Positions(address(vault));

        // Get the current spot price to convert between tokens
        (uint160 sqrtPriceX96,,,,,,) = pool.slot0();
        uint256 spotPrice = UniswapUtils.getQuoteFromSqrtRatioX96(
            sqrtPriceX96, uint128(10 ** (isVaultAssetToken0 ? decimals1 : decimals0)), isVaultAssetToken0
        );

        // Calculate total value by converting all holdings to the vault's asset
        if (isVaultAssetToken0) {
            // If vault's asset is token0, convert token1 to token0
            totalValue = amount0 + position0.value + position1.value.mulDiv(spotPrice, 10 ** decimals1);
        } else {
            // If vault's asset is token1, convert token0 to token1
            totalValue = amount1 + position1.value + position0.value.mulDiv(spotPrice, 10 ** decimals0);
        }
    }

    /**
     * @dev Validates that the spot price is within acceptable range of the TWAP price
     * Reverts if price volatility exceeds the maximum acceptable difference
     * This protects against potential arbitrage attacks during high volatility
     *
     * @param twapPrice The time-weighted average price
     * @param spotPrice The current spot price
     */
    function requireLowVolatility(uint256 twapPrice, uint256 spotPrice) internal pure {
        require(
            !tooMuchVolatility(twapPrice, spotPrice),
            "UniswapV3VaultOperations: Spot price is not within the acceptable range"
        );
    }

    /**
     * @dev Determines if price volatility exceeds acceptable bounds
     * Compares the difference between spot price and TWAP against the maximum allowed difference
     *
     * @param twPrice The time-weighted average price
     * @param spotPrice The current spot price
     * @return bool True if volatility exceeds acceptable bounds, false otherwise
     */
    function tooMuchVolatility(
        uint256 twPrice, // amount of token1 needed for 1 token0
        uint256 spotPrice // amount of token1 needed for 1 token0
    )
        internal
        pure
        returns (bool)
    {
        // Calculate the maximum acceptable price difference based on TWAP
        uint256 acceptablePriceDiff = twPrice.mulDiv(MAX_ACCEPTABLE_PRICE_DIFF_BASIS_POINT, BASIS_POINT_SCALE);

        // Check if the spot price is outside the acceptable range
        // Returns true if volatility is too high
        return !(spotPrice >= twPrice - acceptablePriceDiff && spotPrice <= twPrice + acceptablePriceDiff);
    }

    /**
     * @dev Retrieves both the TWAP and spot prices from the Uniswap V3 pool
     * Returns prices normalized according to the decimals of the price unit token
     *
     * @return twPrice The time-weighted average price over TWAP_PERIOD
     * @return spotPrice The current spot price from the pool
     */
    function getPrices() internal view returns (uint256 twPrice, uint256 spotPrice) {
        // Get the current spot price from the pool
        (uint160 sqrtPriceX96,,,,,,) = pool.slot0();

        // Use the decimals of the token that serves as the price unit
        uint256 decimals = assetIsToken0 ? decimals1 : decimals0;

        // Convert the sqrtPriceX96 to a human-readable price
        spotPrice = UniswapUtils.getQuoteFromSqrtRatioX96(sqrtPriceX96, uint128(10 ** decimals), assetIsToken0);

        // Get the time-weighted average price over TWAP_PERIOD
        twPrice = UniswapUtils.getTwap(pool, TWAP_PERIOD, uint128(10 ** decimals), assetIsToken0);
    }

    /**
     * @dev Calculates the total value of a user's Uniswap V3 positions in the specified pool
     * Includes both the principal token amounts and uncollected fees (minus the protocol fee cut)
     *
     * @param user The address whose positions to calculate
     * @return position0 The total value in token0 with fee adjustments
     * @return position1 The total value in token1 with fee adjustments
     */
    function getAllUniswapV3Positions(address user)
        public
        view
        returns (Position memory position0, Position memory position1)
    {
        // Get the total number of NFT positions owned by the user
        uint256 balance = positionManager.balanceOf(user);

        // Initialize position values
        position0 = Position({token: address(poolToken0), value: 0});
        position1 = Position({token: address(poolToken1), value: 0});

        // Iterate through all positions
        for (uint256 i = 0; i < balance; i++) {
            // Get the tokenId for the current position
            uint256 tokenId = positionManager.tokenOfOwnerByIndex(user, i);

            // Retrieve position details
            (,, address token0, address token1, uint24 fee,,,,,,,) = positionManager.positions(tokenId);

            // Compute the pool address for this position
            PoolAddress.PoolKey memory key = PoolAddress.getPoolKey(token0, token1, fee);
            address computedPoolAddress = PoolAddress.computeAddress(pool.factory(), key);

            // Only count positions in the relevant pool
            if (computedPoolAddress == address(pool)) {
                // Get current price to value the position
                (uint160 sqrtPriceX96,,,,,,) = pool.slot0();

                // Get total position value including fees
                (uint256 amount0, uint256 fee0, uint256 amount1, uint256 fee1) =
                    PositionValue.total(positionManager, tokenId, sqrtPriceX96);

                // Add principal amounts directly
                position0.value += amount0;
                position1.value += amount1;

                // For fees, apply the fee cut before adding
                position0.value += fee0.mulDiv(BASIS_POINT_SCALE - feeCutBasisPoint, BASIS_POINT_SCALE);
                position1.value += fee1.mulDiv(BASIS_POINT_SCALE - feeCutBasisPoint, BASIS_POINT_SCALE);
            }
        }

        return (position0, position1);
    }
}
